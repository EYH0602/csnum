\documentclass[a4paper,12pt]{article}
\usepackage{CodeReport}

\begin{document}


\begin{center} % Everything within the center environment is centered.
	{\Large \bf Coding Report 4} % <---- Don't forget to put in the right number
	\vspace{2mm}
\end{center}  


\section{Problem Description}

Then we compare four methods: Jacobi, Gauss-Seidel, SOR with $\omega = 1.1$ (sor11), and SOR $\omega = 0.9$ (sor09).
The test will be performed random matrices of size $n = 10, 25, 50, 100, 200, 500$.
The linear system $Ax = b$ to solve will have the following setup
$$
A = \frac{n}{2} \times I + R
$$
where random entries $r_{ij}, b_{ij} \sim N(0, 1)$.
We plot their execution time and number of iteration used v.s. $n$.
Finally, we will record errors at every step for $n = 500$ 
and plot it with respect to number of iteration.

\section{Results}

\subsection{Homework Problem}
Let 
$$
A = \begin{bmatrix}
	4 & 1 & -1 \\
	-1 & 3 & 1 \\
	2 & 2 & 6
\end{bmatrix},
b = \begin{bmatrix}
	5 \\ -4 \\ 1
\end{bmatrix}
$$
the code gives solutions
$$
x_j = \begin{bmatrix}
	 1.54166667 \\
	-0.85648148 \\
	-0.05092593 
\end{bmatrix},
x_g = \begin{bmatrix}
	 1.45196759 \\
	-0.83391204 \\
	-0.03935185 
\end{bmatrix},
x_s = \begin{bmatrix}
	 1.43231701 \\
	-0.83290758 \\
	-0.02942417 
\end{bmatrix},
$$
which are the same as the results from homework if we round the solution to 3 digits.


\subsection{Comparison}

We compare the time and iteration used for each methods until the relative update falls below $10^{-8}$.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.55\textwidth]{img/report3_cell_11_output_1.png}
    \caption{wall clock time v.s. $n$ size of matrix}
    \label{fig:0}   
\end{figure}

For execution time,
we can see that Gauss-Seidel is the fastest for each $n$,
followed by Jacobi and two SOR methods.
Gauss-Seidel is generally a order faster than Jacobi,
and SOR behaves similar for $\omega = 1.1, 0.9$.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.55\textwidth]{img/report3_cell_13_output_1.png}
    \caption{number of iterations v.s. $n$ size of matrix}
    \label{fig:1}   
\end{figure}

For number of iteration,
we can see that Gauss-Seidel is still the lowest.
When $n$ is small (i.e. $\leq 100$). SOR methods uses less iteration than Jacobi,
but Jacobi uses lower number of iteration when the size goes up.
One thing to note is that with larger $n$,
it requires less number of iteration to converge for all methods.
Two SOR methods still behaves similarly and not ideally,
this might be caused by bad choices by $\omega$.
Another reason might be that these random $A$ are low-rank diagonal matrices,
for which Jacobi and Gauss-Seidel methods have a smaller spectral radius than SOR,
which leads to faster convergence of Jacobi and Gauss-Seidel.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.55\textwidth]{img/report3_cell_15_output_1.png}
    \caption{Error of each methods at $n = 500$ v.s. number of iteration}
    \label{fig:2}   
\end{figure}

Errors at each step also shows a similar trend that Gauss-Seidel is the lowest,
followed by Jacobi and SOR.
And the differences in errors becomes hard to distinguish after about 4 iterations.

For $\hat{A} = randn(n, n)$ matrices,
sometimes Jacobi and Gauss-Seidel failed to converge since $\hat{A}$ may not be diagonally dominant.


\section{Collaboration}
No collaboration on this project.


\section{Academic Integrity}
On my personal integrity as a student and member of the UCD community, I have not given nor received any unauthorized assistance on this assignment.


\section{Appendix}
\lstinputlisting[language=Python, title=\url{numerical_methods/linear_iter_methods.py}]{../numerical_methods/linear_iter_methods.py}
\lstinputlisting[language=Python, title=main.py]{report3.py}

\end{document}